#Var to save global tcp  


global_tcp = p[-100.64/1000, 6.55/1000, 72.44/1000, 0,0,0]
global aux_tcp = p[-100.64/1000, 6.55/1000, 133.44/1000, 0,0,0]
global float_value = 0
gripkit_easy_enable()

#fine tune points 
global Camera_ck_position_Sepa = p[376/1000,-130/1000 ,167.40/1000,2.215, 2.228, 0 ]
global Camera1 = p[376/1000, -130.92/1000, 142/1000, 2.212, 2.236, -0.020]
global DropHead = p[268.75/1000, -365.08/1000, 115.06/1000, 2.206, 2.237, 0]
global buffer_position = p[271.48/1000, -369.02/1000, 85.38/1000, 2.196, 2.255, -0.0004]
global Camera2 = p[362.75/1000, -14.75/1000, 137.24/1000, 2.232, -2.211, 0]
global Camera1Up = p[321.86/1000, -17.30/1000, 530.53/1000, 2.232, -2.211, 0]
global Camera2Up = p[338.54/1000, -130.92/1000, 538.8/1000, 2.228, 2.235, -0.023]



#optical to key parametres
#Global Parameters
global blend_radius_m = 0.001

#Global parameters  between cam and tcp tool v2_
global dx_nut_left = 0.35
global dy_nut_left = 107.99
global dz_nut_left = 61.17


global dx_nut_rigth = 0.35
global dy_nut_rigth = 107.99
global dz_nut_rigth = 61.17


global dx_hole = 0.35
global dy_hole = 107.99  
global dz_hole = 45

global_num_cam= 0

#Var to save global tcp  
#global_tcp = p[-0.082500, -0.001000, 0.071500, 0 , 0, 0]






def mainUR5():



  ##############################################################################################################################
  ##############################################################################################################################
  ##################################################### STATES & FUNCTIONS #####################################################
  ##############################################################################################################################
  ##############################################################################################################################

  #######################################################
  ############### FOO_1 SET DESIRED SPEED ###############
  #######################################################

  def set_Speed(vel_ms, vel_rads, acel_ms, acel_rads ): 
    #default: speed_ms = 0.3 speed_rads = 0.75 accel_mss = 3 accel_radss = 1.2 
    global speed_ms = vel_ms
    global speed_rads = vel_rads
    global accel_mss = acel_ms
    global accel_radss = acel_rads
  end

  #######################################################
  ############# FOO_2 WRITE IN REGISTER INT #############
  #######################################################

  def write_state_int(register, value):
    write_output_integer_register(register, value)
    sleep(0.1)
  end

  #######################################################
  ############# FOO_3 READ IN REGISTER INT ##############
  #######################################################

  def read_state_int(register):
    while (read_input_integer_register(register) ==   -1  ):	  	  
      sync()
    end
    return(read_input_integer_register(register))
  end

  #######################################################
  ############# FOO_4 INITIALIZE REGISTER ###############
  #######################################################

  def init_register(register0, register1, register2, value):
    write_state_int(register0, value)
    write_state_int(register1, value)
    write_state_int(register2, value)
  end

  #######################################################
  ################ FOO_5 RESET REGISTER #################
  #######################################################

  def reset_register(register0, register1, register2, value):
    write_state_int(register0, value)
    write_state_int(register1, value)
    write_state_int(register2, value)
    write_state_int(register0, 10)
    write_state_int(register1, 10)
    write_state_int(register2, 10)
  end

  #######################################################
  ############### FOO_6 INITIALIZE STATUS ###############
  #######################################################

  def init_status(register0, register1, register2):
    global status0=read_state_int(register0)
    global status1=read_state_int(register1)
    global status2=read_state_int(register2)
  end

  #######################################################
  ######## FOO_7 CHECK STATUS RECEIVED FROM PLC #########
  #######################################################

	def CheckStatus(state):

		if (status0==state and status1==state and status2==state or status0==state and status1==state and status2!=state or status0==state and status1!=state and
		 status2==state or status0!=state and status1==state and status2==state):
		  return True
		else:
		  return False
		end

	end

  #######################################################
  ############# FOO_8 WRITE, READ AND RESET IN REGISTER BOOL ############
  #######################################################

	def write_state_bool(register0,register1,register2):
	  write_output_boolean_register(register0, True)
	  write_output_boolean_register(register1, True)
	  write_output_boolean_register(register2, True)
	end
	
	
	def reset_state_bool(register0,register1,register2):
	  	write_output_boolean_register(register0, False)
		write_output_boolean_register(register1, False)
		write_output_boolean_register(register2, False)
	
	end
	
	def read_state_bool(r0,r1,r2, state):
	
	
		register0 = read_input_boolean_register(r0)
		register1 = read_input_boolean_register(r1)
		register2 = read_input_boolean_register(r2)
	
		if ((register0==state and register1==state and register2==state) or 
		    (register0==state and register1==state and register2!=state) or 
			(register0==state and register1!=state and register2==state) or 
			(register0!=state and register1==state and register2==state)):
			return True
		else:
			return False
		end
	end


  ######################################################################
  #### FOO_9 CHECKS IF THE SEPARATOR HAS BEEN TAKEN BY THE GRIPPER #####
  ######################################################################
   
 
   	def CheckGripState(number):
	
	    while (gripkit_easy_get_state()!=number):
			sync()
		end
	end
	
	
	######################################################################
  #### FOO_10 READ AND CHECK VALUES PLC-VISION SYSTEM #####
  ######################################################################
  
  ##check if two of tree values are the same, to avoid bad variables intercahnages between vision system- plc and robot
  ##return true to indicate that the variables are correct
  
  
    def read_float_values(register0, register1, register2):
		 Val1 = read_input_float_register(register0)
		 Val2 = read_input_float_register(register1)
		 Val3 = read_input_float_register(register2)
		 
		 float_value = 0
		 
		 if Val2 == Val3:
			float_value = Val2
			return True		
		elif Val1 == Val3:
			float_value = Val1
			return True		
		elif Val1 == Val2:
			float_value = Val2
			return True		
		elif (Val1 == Val2 and Val1 == Val3 and Val2 == Val3):
			float_value = Val2
			return True			
		else:	
			float_value = -1
			return False
			
		end
	 
	 
	end

  ######################################################################
  ## THREAD_1 MAKE SURE THE GRIPPER IS ALWAYS GRIPPING WHEN IT HAS TO ##
  ######################################################################

  	#thread AlwaysCloseGripper(start):
	  #while(True):
	#	if gripkit_easy_get_state()!=3: #3=gripping
	#		gripkit_easy_grip()
	#	end
	#	sync()
	#  end
  	#end	#use commands: "start_thrd = run AlwaysCloseGripper_thrd()"   and    "kill start_thrd"  IN order to init and stop the thread execution
  
  ##############################################
  ############### STATE_0 HOMING ###############
  ##############################################

	def UR5Home():
		
	  init_register(3,4,5,500)
  	gripkit_easy_enable()  #ESTO DEBERIA IR EN LA MARCHA DE PREPARACIÃ“N
	  movej([0.000000, -0.174533, -2.775074, -0.349066, 1.570796, 1.570796],accel_radss,speed_rads,0,blend_radius_m)
  	reset_register(3,4,5,501)

	end

  #########################################################################
  ############### STATE_1 PLACE THE CAMERA ON THE FIRST HEAD ##############
  #########################################################################

	def UR5Camera1():

		init_register(3,4,5,510)
		movej([-0.000001, -0.174533, -2.775074, -0.349065, 1.570797, 1.570796],accel_radss,speed_rads,0,blend_radius_m)
		movej([0.117466, -0.388481, -2.711615, -1.543640, 1.554572, 1.648531],accel_radss,speed_rads,0,blend_radius_m)
		movej([0.231982, -1.497769, -2.397802, -0.820452, 1.569986, 3.397634],accel_radss,speed_rads,0,blend_radius_m)		
		# fine tuning point	
		movel(Camera1,accel_mss/2,speed_ms/2)
		reset_register(3,4,5,511)
		
	end
  

  ########################################################################
  ####################### STATE_2 GO TO THE BUFFER #######################
  ########################################################################

	def UR5DropHead():

	init_register(3,4,5,520)
	#set tcp after ctr_nut
	set_tcp(global_tcp)
	sleep(0.5)
  	movej([-0.079655, -1.322085, -2.567424, -0.844223, 1.573142, 3.068075],accel_radss,speed_rads,0,blend_radius_m)
	movel(p[267.04/1000, -365.56/1000, 134/1000, 2.228, 2.223, -0.031], accel_mss, speed_ms)
	
	
	#check if the screw wrench has been correctly positioned on the screw
	#vars to ck continuously
	global collision_flag = 0	
	zero_ftsensor()	

	#set forces to compare 
	#global force_UR5 = 60 
	#global force_UR3 = -1
	#global id_get_Force = run get_Force()
	
	#fine tune point
	movel(DropHead, accel_mss/2, speed_ms/2)
	
				
	#down the tool with force 		
	#Apply force in z axis to down robot
	limits = [2/1000, 2/1000, 100/1000, 0.34, 0.34, 0.34] #limits or move velocity
	frame = tool_pose() #tool or base frame
	selection = [1, 1, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
	wrench = [0, 0, 10, 0, 0, 0] # force to apply
	type = 2 #kind or force mode
	zero_ftsensor()				
	force_mode(frame, selection , wrench, type, limits)
	
    #waits until the screw enters the hole
	while (True):
	 actual_pos = get_actual_tcp_pose ()
	 z_pos = actual_pos[2]
	 if z_pos <= 0.09:
	  break	
	 end
	sync() 
	end 
	end_force_mode()
	
	   
  	reset_register(3,4,5,521)
		
	end
  
  ###################################################################
  ########## STATE_3 PLACE THE CAMERA ON THE SECOND HEAD  ###########
  ###################################################################

	def UR5Camera2():

  	init_register(3,4,5,530)
    movej([-0.294304, -1.431164, -2.396163, -0.903647, 1.576685, 2.661407],accel_radss,speed_rads,0,blend_radius_m)
    movej([-0.267132, -1.009988, -2.620157, -1.089319, 1.576027, 1.340146],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.090976, -1.419510, -2.326645, -0.966237, 1.570793, 0.090976],accel_radss,speed_rads,0,blend_radius_m)
	# fine tuning point
	movel(Camera2, accel_mss/2, speed_ms/2)
  	reset_register(3,4,5,531)

	end

  ###########################################################################################
  ################ STATE_4 PLACE THE CAMERA ON THE FIRST HEAD TO BE SCREWED  #################
  ###########################################################################################

	def UR5UpCamera1():

  	init_register(3,4,5,540)
	
	#set tcp after ctr_nut
	set_tcp(global_tcp)
	movej(p[367.4/1000, -13.48/1000, 146.97/1000, 2.179, -2.263, -0.030], accel_radss,speed_rads,0,blend_radius_m) 
  	movej([0.020342, -0.907042, -1.576383, -2.245466, 1.571112, 1.591136],accel_radss,speed_rads,0,blend_radius_m)
    movej(p[297.65/1000, -17.08/1000, 528.73/1000, 2.244, -2.199, -0.030],accel_radss,speed_rads,0,blend_radius_m)#altura 523.43
	movel(Camera1Up, accel_mss, speed_ms, 0, blend_radius_m)
	
  	reset_register(3,4,5,541)

	end


  ###########################################################################################
  ############## STATE_5 GOES DOWN FROM THE SCREWING TO THE BUFFER POSITION  ################
  ###########################################################################################

	def UR5TakeBuffer():
	
	init_register(3,4,5,550)
	
	#movej(p[284.5/1000, -14.136/1000, 574.324/1000, -2.245, 2.166, 0.097],accel_radss,speed_rads,0,blend_radius_m)
	movej([0.020342, -0.907042, -1.576383, -2.245466, 1.571112, 1.591136],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.114668, -0.430573, -2.101027, -2.007478, 1.547060, 0.523599],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.068591, -0.020420, -2.584134, -1.623156, 1.570796, 0.523599],accel_radss,speed_rads,0,blend_radius_m)
    movej([-0.076969, -0.860622, -2.748894, -1.065873, 1.573414, 0.929562],accel_radss,speed_rads,0,blend_radius_m)
  	movej([-0.079655, -1.322085, -2.567424, -0.844223, 1.573142, 3.068075],accel_radss,speed_rads,0,blend_radius_m)
	movel(p[267.04/1000, -366.65/1000, 134/1000, 2.237, 2.232, -0.035], accel_mss, speed_ms)
 
	#check if  tool insert correctly
	#vars to ck continuously
	global collision_flag = 0	
	zero_ftsensor()	
	#sleep(0.1)

	#move fine position
	movel(buffer_position,  accel_mss/4, speed_ms/4)
	
	#down with force to ensure proper insertion 
	#Apply force in z axis to down robot
	limits = [2/1000, 2/1000, 10/1000, 0.34, 0.34, 0.34] #limits or move velocity
	frame = tool_pose() #tool or base frame
	selection = [1, 1, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
	wrench = [0, 0, 5, 0, 0, 0] # force to apply
	type = 2 #kind or force mode
	zero_ftsensor()				
	force_mode(frame, selection , wrench, type, limits)
	
    #waits until the key enters into the nut
	while (True):
	 actual_pos = get_actual_tcp_pose ()
	 z_pos = actual_pos[2]
	 if z_pos <= 75/1000:
	  break	
	 end
	sync() 
	end 
	end_force_mode()
	
	
	
	#set forces to compare 
	global force_UR5 = 10 
	global force_UR3 = -10 
	global id_get_Force = run get_Force()
	
	sleep(2)
	
	# get the flag value
	if collision_flag == 1:
		write_state_bool(0,1,2)
		sleep(0.5)
	elif collision_flag == 0:
		reset_state_bool(0,1,2)
		sleep(0.5)
		#Continue normaly is all is correct 
		# close the tool and check if the head is pressed
		gripkit_easy_grip()
		CheckGripState(3) #wait to the tool has gripped the separator correctly
	
	end	
	

    kill id_get_Force    
	
  	reset_register(3,4,5,551)
	sleep(0.5)
	reset_state_bool(0,1,2)
	end
  
  ###########################################################################################
  ############### STATE_6 PLACE THE CAMERA ON THE SECOND HEAD TO BE SCREWED  ################
  ###########################################################################################

	def UR5UpCamera2():

  	init_register(3,4,5,560)
	
  	movel([-0.079655, -1.322085, -2.567424, -0.844223, 1.573142, 3.068075],accel_mss,speed_ms,0,blend_radius_m)
    movej([-0.076969, -0.860622, -2.748894, -1.065873, 1.573414, 0.929562],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.068591, -0.020420, -2.584134, -1.623156, 1.570796, 0.523599],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.114668, -0.430573, -2.101027, -2.007478, 1.547060, 0.523599],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.020342, -0.907042, -1.576383, -2.245466, 1.571112, 1.591136],accel_radss,speed_rads,0,blend_radius_m)
    movep(Camera2Up, accel_mss, speed_ms)
	
  	reset_register(3,4,5,561)

	end


  ###########################################################################################
  ########## STATE_7 FROM THE INSTALLATION AREA IT RETURNS TO HOME. END OF CICLE  ###########
  ###########################################################################################

	
	def UR5Return():

  	init_register(3,4,5,570)
  	movej([0.020342, -0.907042, -1.576383, -2.245466, 1.571112, 1.591136],accel_radss,speed_rads,0,blend_radius_m)
    movej([0.114668, -0.430573, -2.101027, -2.007478, 1.547060, 0.523599],accel_radss,speed_rads,0,blend_radius_m)
    movej(p[210/1000, -105.973/1000, 142.209/1000, -0.865, 2.984, -0.016],accel_radss,speed_rads,0,blend_radius_m)
    UR5Home()
    movej([0.058643, 0.046251, -2.850123, -1.694540, 3.083473, 1.753881],accel_radss,speed_rads,0,blend_radius_m)
  	reset_register(3,4,5,571)

	end

	
	
  #######################################################
  ####### STATE_8_0 CHECK CORRECT SEPARATOR POSITION ########
  #######################################################
  
  def UR5CkPosSepator():
		
		init_register(3,4,5,690)
		
		movel(Camera_ck_position_Sepa,accel_mss/2,speed_ms/2)
        
		reset_register(3,4,5,691)
		

  
  end
	
  #######################################################
  ####### STATE_8_1 CONTROL RIGHT HEAD ROTATION ########
  #######################################################
  
  def CtrHeadTurn(n_cam):
  
      #right head
	  if n_cam == 1:
	  
	  	#return to last pose UR5Camera1 after checv separator position
		movel(Camera1, accel_mss, speed_ms, 0, blend_radius_m)
		aux_I = 700
		aux_F = 701
		
		#wait until the values are read
		while (not read_float_values(9,10,11)):
		  sync()
		end
	#left head	
	 elif n_cam == 2:
		aux_I = 710
		aux_F = 711
		
		#wait until the values are read
		while (not read_float_values(12,13,14)):
			sync()
		end
	  end
	  
	  #set register to indicate begin of state
	  init_register(3,4,5,aux_I)
	  # picth value deviation from plc and vision system from subfunction read_float_values
  	  turn_head = float_value 
	  
	  ## added 61 mm to Z-axis TCP to compensate the level between the nut and socket wrench heigth
	  set_tcp(aux_tcp)
	  sleep(0.1)
	  #turn the desviaton between head separator and tool robot
	  data = p[ 0,0,0,d2r(turn_head),0,0] # trasform to position variable in base coordinates
	  tcp_inst= get_actual_tcp_pose () # get the actual tcp positions.
	  pos_calculate = pose_add (tcp_inst, data )
	  movel(pos_calculate, accel_mss/4, speed_ms/2, 0, blend_radius_m)
	  stopl(2)
	  
	  #reset variables 
	  float_value = 0
	  reset_register(3,4,5,aux_F)
  
   end
  #######################################################
  ####### STATE_8 CONTROL TO CENTER CAM OVER NUT ########
  #######################################################

	def CtrCamPos(x_s, y_s):
		
		init_register(3,4,5,580)
		
		#x_s: direction of x_axis
		#y_s: direction of y_axis
		
        # x-axis deviation #wait until the values are read
		while (not read_float_values(0,1,2)):
			sync()
		end
		cx = float_value
		
		# y-axis deviation #wait until the values are read
		while (not read_float_values(3,4,5)):
			sync()
		end
		cy = float_value
			
		x = x_s*(cx/1000)
		y = y_s*(cy/1000)		
		data_vision = p[ x,y,0,0,0,0] # trasform to position variable in base coordinates
		tcp_inst = get_actual_tcp_pose () # get the actual tcp positions.
		pos_calculate = pose_add (tcp_inst, data_vision )
		movel(pos_calculate, accel_mss, speed_ms, 0, blend_radius_m)

		reset_register(3,4,5,581)

	end 

  #######################################################
  ########### STATE_9 MOVE TO NUT AND DOWN ##############
  #######################################################
  
	def MoveToNut(x_s,y_s,n_cam):

		init_register(3,4,5,590)
		#dx,dy,dz, distance between optical cam center and nut center
		
		num_cam = n_cam
		
		dx = 0
		dy = 0
		dz = 0
		
		# check what distance take depending of state unscrew the nut or screw  head 
		if n_cam == 1 :
			dx = dx_nut_rigth
			dy = dy_nut_rigth
			dz = dz_nut_rigth
		elif n_cam ==2:
			dx = dx_nut_left
			dy = dy_nut_left
			dz = dz_nut_left	
		elif n_cam == 3 or n_cam == 4:	
			dx = dx_hole
			dy = dy_hole
			dz = dz_hole
		end
		
		#get new point and move
		tcp_inst = get_actual_tcp_pose()
		tcp_to_optical_center = p[x_s*(dx/1000),y_s*(dy/1000),0,0,0,0]
		pos_nut = pose_add(tcp_inst, tcp_to_optical_center)
		movel(pos_nut ,accel_mss, speed_ms, 0, blend_radius_m)
		
		
		#move tool to inside nut
		set_Speed(0.05, 0.75, 0.25, 1.2)
		tcp_inst = get_actual_tcp_pose()
		tcp_to_nut = p[0,0,dz/1000,0,0,0]
		pos_nut = pose_trans (tcp_inst, tcp_to_nut)	
        
		#*********************************************************************
		#call a function-thread to ck the correct execute
		#check if the screw wrench has been correctly positioned on the screw
		
		#vars to ck continuously
		global collision_flag = 0	
		zero_ftsensor()	
		
		#set forces to compare depending of position 
		if n_cam ==1 or n_cam== 2 : 		
			global force_UR5 = 60 
			global force_UR3 = 3
		elif n_cam ==3 or n_cam== 4 : 
			global force_UR5 = 25 
			global force_UR3 = 20
		end
		global id_get_Force = run get_Force()
		#move tool to inser into nut 
		movel(pos_nut, accel_mss, speed_ms)
		
		sleep(2)
		
		# get the flag value
		if collision_flag == 1:
			write_state_bool(0,1,2)
			sleep(0.5)
		elif collision_flag == 0:
			reset_state_bool(0,1,2)
			sleep(0.5)
			#Continue normaly is all is correct 
			# close the tool and check if the head is pressed
			gripkit_easy_grip()
			CheckGripState(3) #wait to the tool has gripped the separator correctly
		
		end

		kill id_get_Force
		reset_register(3,4,5,591)
		num_cam = -1
		
		sleep(0.1)
		reset_state_bool(0,1,2)
		
	end
	
	
		 
			 
			 
			
	
	thread get_Force():
	
	
		#function to read Z axis force from ur3->twincat
	    def read_float_values_th(register0, register1, register2):
			 Val1 = read_input_float_register(register0)
			 Val2 = read_input_float_register(register1)
			 Val3 = read_input_float_register(register2)
			 
			 float_value = 0
			 
			 if Val2 == Val3:
				float_value = Val2
				return True		
			elif Val1 == Val3:
				float_value = Val1
				return True		
			elif Val1 == Val2:
				float_value = Val2
				return True		
			elif (Val1 == Val2 and Val1 == Val3 and Val2 == Val3):
				float_value = Val2
				return True			
			else:	
				float_value = -1
				return False
				
			end
	 
	 
		end
	
	
	
		#loop to read and compare UR3 and UR5 forces
		while True:
			# get ur5 forces 
			#force_tcp = get_tcp_force()
			UR5_norm_force = force()
			
			Ur3_z_force = 0
			
			#read force from Ur3 and wait until complete read
			while (not read_float_values_th(15,16,17)):
				sync()
			end
			
            #UR3 abs force value 		
			Ur3_z_force = norm(float_value)
			
			#constan to compare
			force_detect_UR5_tool = force_UR5 
			force_detect_UR3_z = force_UR3
			
			#check conditions 
			if (UR5_norm_force > force_detect_UR5_tool):
				if (Ur3_z_force > force_detect_UR3_z):
					 collision_flag = 1
					break
					
				end
				
			end	 
			sync()	 
		end 
		
	end  
	
	
	
  #######################################################
  ############ STATE_9.1 CORRECT INSERTION #############
  #######################################################
  
  def Correct_Insertion():
		init_register(3,4,5,7300)
		
		#up the tool
		tcp_inst = get_actual_tcp_pose()
		tcp_to_nut = p[0,0,-20/1000,0,0,0]
		pos_nut = pose_trans (tcp_inst, tcp_to_nut)
		movel(pos_nut, accel_mss, speed_ms)
		
		#down the tool wiht force 
		
		#Apply force in z axis to down robot
		limits = [0.1, 0.1, 0.1, 0.34, 0.34, 0.34] #limits or move velocity
		frame = tool_pose() #tool or base frame
		selection = [1, 1, 0, 0, 0, 1] #[x,y,z,x,ry,rz]
		wrench = [0, 0, 0, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		zero_ftsensor()
		
		#reset force zensor Ur3
		write_state_bool(0,1,2)
		sleep(0.1)
		reset_state_bool(0,1,2)
		
	    #apply force
		force_mode(frame, selection , wrench, type, limits)
		
		#move tool
		tcp_inst = get_actual_tcp_pose()
		tcp_to_nut = p[0,0,20/1000,0,0,0]
		pos_nut = pose_trans (tcp_inst, tcp_to_nut)
		movel(pos_nut, accel_mss, speed_ms)
		

		
		#read Ur3 force to check if tool inser into nut
		while True:
		
			#read force from Ur3 and wait until complete read
			while (not read_float_values(15,16,17)):
				sync()
			end			
			Ur3_normal_force = 0
			Ur3_normal_force = float_value
			
			#read force from Ur5
			UR5_norm_force = force()
			
			force_detect_UR3_normal = 2
			force_detect_UR5_tool =   30

			if Ur3_normal_force < force_detect_UR3_normal:
				#if UR5_norm_force < force_detect_UR5_tool:
				break
				#end
			end 
			sync()
		end
		
		# close the tool and check if the head is pressed
		gripkit_easy_grip()
		CheckGripState(3) #wait to the tool has gripped the separator correctly
		
		
		end_force_mode()
		
		reset_register(3,4,5,7301)
  end
  
  
    #######################################################
  ############ STATE_9.2 CORRECT INSERTION BUFFER#############
  #######################################################
  
  def Correct_Insertion_buffer():
		init_register(3,4,5,7300)
		
		#up the tool
		tcp_inst = get_actual_tcp_pose()
		tcp_to_nut = p[0,0,-10/1000,0,0,0]
		pos_nut = pose_trans (tcp_inst, tcp_to_nut)
		movel(pos_nut, accel_mss, speed_ms)
		
		#down the tool wiht force 
		
		#Apply force in z axis to down robot
		limits = [0.1, 0.1, 0.1, 0.34, 0.34, 0.34] #limits or move velocity
		frame = tool_pose() #tool or base frame
		selection = [1, 1, 0, 0, 0, 0] #[x,y,z,x,ry,rz]
		wrench = [0, 0, 0, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		zero_ftsensor()	
	
	    #apply force
		force_mode(frame, selection , wrench, type, limits)
		
		#move tool
		tcp_inst = get_actual_tcp_pose()
		tcp_to_nut = p[0,0,10/1000,0,0,0]
		pos_nut = pose_trans (tcp_inst, tcp_to_nut)
		movel(pos_nut, accel_mss, speed_ms)
		

		
		#read Ur5 force to check if tool inser into nut
		while True:
		
			
			#read force from Ur5
			UR5_norm_force = get_tcp_force()
			UR5_z_force	= UR5_norm_force[2]
			
			force_detect_UR5_tool =  20
			if UR5_z_force < force_detect_UR5_tool:
				break
			end

			sync()
		end
		
		# close the tool and check if the head is pressed
		gripkit_easy_grip()
		CheckGripState(3) #wait to the tool has gripped the separator correctly
		
		
		end_force_mode()
		
		reset_register(3,4,5,7301)
  end


    #######################################################
  ############ STATE_9.2 CORRECT INSERTION HOLE#############
  #######################################################
  
  def Correct_Insertion_hole():
		init_register(3,4,5,7300)
		
		
		#search hole 
		
		tcp_init = get_actual_tcp_pose()
		global flag_move = 0
		th_mv = 10/1000
		


		global flag_insert_nut_hole = False
	    global id_find_hole = run find_hole()	


		#loop to read and compare UR3 and UR5 forces
		while True:
		
			#read force from Ur3 and wait until complete read
			while (not read_float_values(15,16,17)):
				sync()
			end	
			
            #UR3 abs force value 		
			Ur3_z_force = norm(float_value)
					
			#check conditions 
				if (Ur3_z_force < 2):
					flag_insert_nut_hole = True					
					kill id_find_hole
					stopl(1.2)
					break

				end

			sync()	 
		end 

		
		reset_register(3,4,5,7301)
  end



	thread find_hole():
	
		
		enter_critical
		accel_mss_i = 15/1000
		speed_ms_i = 20/1000
	
		i = 0
		tcp_inst = get_actual_tcp_pose()
		ini_x = 10
		ini_y = 10 
		
		x_delta = 20
		y_delta = 2 
		
		tcp_to_nut = p[ini_x/1000,ini_y/1000,0,0,0,0]
		pos_nut = pose_add (tcp_inst, tcp_to_nut)
		movel(pos_nut, accel_mss_i, speed_ms_i)

		while i < 5:
			# move x_axis
			tcp_inst = get_actual_tcp_pose()
			tcp_to_nut = p[-x_delta/1000,0,0,0,0,0]
			pos_nut = pose_add (tcp_inst, tcp_to_nut)
			movel(pos_nut, accel_mss_i, speed_ms_i)
			


			# move -y_axis
			tcp_inst = get_actual_tcp_pose()
			tcp_to_nut = p[0,-y_delta/1000,0,0,0,0]
			pos_nut = pose_add (tcp_inst, tcp_to_nut)
			movel(pos_nut, accel_mss_i, speed_ms_i)
			
			
			# move -x_axis
			tcp_inst = get_actual_tcp_pose()
			tcp_to_nut = p[x_delta/1000,0,0,0,0,0]
			pos_nut = pose_add (tcp_inst, tcp_to_nut)
			movel(pos_nut, accel_mss_i, speed_ms_i)
			

			# move -y_axis
			tcp_inst = get_actual_tcp_pose()
			tcp_to_nut = p[0,-y_delta/1000,0,0,0,0]
			pos_nut = pose_add (tcp_inst, tcp_to_nut)
			movel(pos_nut, accel_mss_i, speed_ms_i)
			
			
		i = i + 1
		sync()
		end
	
		

		exit_critical

	end  
	
  #######################################################
  ############ STATE_10 UNSCREW AND UP TOOL #############
  #######################################################
  
	def UnScrew():
		init_register(3,4,5,5100)
		
		#change normal tcp
		set_tcp(global_tcp) 
		
		#close tool
		gripkit_easy_grip()		
		CheckGripState(3) #wait to the tool has gripped the separator correctly
		
		#Apply force in z axis to up robot 
		limits = [0.1, 0.1, 0.15, 0.34, 0.34, 0.34] #limits or move velocity
		frame = tool_pose() #tool or base frame
		selection = [0, 0, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
		wrench = [0, 0, -0.5, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		
		zero_ftsensor() # clear force sensor
		#init force mode
		force_mode(frame, selection , wrench, type, limits)
		
		# wait to servomotor finish to unscrew
		Qrob_finish  = False		
		while (not( Qrob_finish )):
		  Qrob_finish  = read_state_bool(0,1,2, True)	
		  sync()
		end
		
		# kill force mode
		end_force_mode()	

		# Up the robot 15 mm
		sleep(1)
		tcp_inst = get_actual_tcp_pose()
		up_distance = p[0,0,-15/1000,0,0,0]
		pos_up = pose_trans (tcp_inst, up_distance)
		set_payload(3.89,[-102/1000,6/1000,-17/1000]) #adjust new weight of the tool
		set_Speed(0.05, 0.75, 0.1, 1.2)
		zero_ftsensor()	


	    #check if the head is completely out
		
		#var to ck force thread 
		global collision_flag = 0	
		
		
		#set forces to compare 
		global force_UR5 = 20 
		global force_UR3 = 10
		global id_get_Force = run get_Force()
		#move tool 
		movel(pos_up, accel_mss, speed_ms, 0, blend_radius_m)
		
		sleep(2)
		write_state_bool(3,4,5)#flag to indicate robot finish movemnet 
		
		# get the flag value
		if collision_flag == 1:
			#head cant out, apply UR5 up force until head out
			
			write_state_bool(0,1,2)#flag to init Qrob
			sleep(0.5)
			
			
			#read Ur3 force to check if head out
			while True:
			
				#read force from Ur3 and wait until complete read
				while (not read_float_values(15,16,17)):
					sync()
				end	
				
				Ur3_z_force = 0
				Ur3_z_force = float_value
				
				#read force from Ur5
				UR5_force = get_tcp_force()
				UR5_norm_z = UR5_force[2]
				
				force_detect_UR3_tool_z = -20
				force_detect_UR5_tool_z =  -10

				if Ur3_z_force < force_detect_UR3_tool_z:
					if UR5_norm_z <  force_detect_UR5_tool_z:
						break
					end
				end 
				sync()
			end

		end
		
		
		#up the tool 20 mm
		tcp_inst = get_actual_tcp_pose()
		up_distance = p[0,0,-20/1000,0,0,0]
		pos_up = pose_trans (tcp_inst, up_distance)
		set_payload(3.89,[-102/1000,6/1000,-17/1000]) #adjust new weight of the tool
		set_Speed(0.05, 0.75, 0.3, 1.2)
		movel(pos_up, accel_mss, speed_ms, 0, blend_radius_m)

		#end force thread and reset flags
		kill id_get_Force
		reset_state_bool(0,1,2)
		reset_state_bool(3,4,5)
		sleep(0.1)
	
		reset_register(3,4,5,5101)
	end
	
	#######################################################
	############ STATE_11 MOVE TO NUT AND DOWN ############
	#######################################################  

	def Screw():
		init_register(3,4,5,5110)

		#Apply force in z axis to down robot
		limits = [0.1, 0.1, 0.15, 0.34, 0.34, 0.34] #limits or move velocity
		frame = p[0,0,0,0,0,0] #tool or base frame
		selection = [0, 0, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
		wrench = [0, 0, -5, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		zero_ftsensor()
		
		force_mode(frame, selection , wrench, type, limits)
		
		Qrob_finish  = read_state_bool(0,1,2, True)
		# wait to servomotor finish to unscrew
		while (not( Qrob_finish )):
		  Qrob_finish  = read_state_bool(0,1,2, True)	
		  sync()
		end
		
		# kill force mode
		end_force_mode()
		#get position of buffer 
		#buffer_position = get_actual_tcp_pose()
		reset_register(3,4,5,5111)
	end  
	

		#######################################################
	############ STATE_72 ScrewHigh ############
	#######################################################  

	def ScrewHigh():
		init_register(3,4,5,5130)
		reset_state_bool(0,1,2)
		sleep(0.1)

		#Apply force in z axis to down robot
		limits = [0.5, 0.5, 0.15, 3.14, 3.14, 3.14] #limits or move velocity
		frame = tool_pose() #tool 
		selection = [0, 1, 1, 0, 0, 1] #[x,y,z,x,ry,rz]
		wrench = [0, 0, 15, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		sleep(0.02)
		zero_ftsensor()
		
		force_mode(frame, selection , wrench, type, limits)
		
		
		#wait to torque be the midle to open the tool 
		Torque_middle  = read_state_bool(0,1,2, True)
		# wait to servomotor finish to unscrew
		while (not( Torque_middle )):
		  Torque_middle  = read_state_bool(0,1,2, True)	
		  sync()
		end
		
	    #Open the tool
		gripkit_easy_release()
		CheckGripState(1) #check if the tool is open
		sleep(0.5)
		
		
		Qrob_finish  = read_state_bool(0,1,2, True)
		# wait to servomotor finish to unscrew
		while (not( Qrob_finish )):
		  Qrob_finish  = read_state_bool(0,1,2, True)	
		  sync()
		end
		

		# kill force mode
		end_force_mode()
		sleep(0.1)
			
		#wait to relievf torque 
		freedrive_mode()
		sleep(2)
		end_freedrive_mode()


		
		reset_register(3,4,5,5131)
		sleep(0.1)
		write_state_bool(0,1,2)

	end  
	
	#######################################################
	########## STATE_12 UP ROBOT AFTER TO SCREW ###########
	#######################################################  	
	def UpRobotAs(type):
	
		
		up_tool = 0 
		selection = [0, 0, 0, 0, 0, 0]
		force_up = 0
		init_register(3,4,5,5120)
		
		
		if type == 1:#Screw high
			selection = [0, 0, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
			up_tool = -50
			force_up = -100
		elif type == 2: #drop buffer up			
			selection = [0, 0, 1, 0, 0, 0] #[x,y,z,x,ry,rz]
			up_tool = -50
			force_up = -50
			#Open the tool
			gripkit_easy_release()
			CheckGripState(1) #check if the tool is open

		end

		#Apply force in z axis to up robot
		limits = [10/1000, 10/1000, 50/1000, 0.17, 0.17, 0.17] #limits or move velocity
		frame = tool_pose() #tool or base frame
		wrench = [0, 0, force_up, 0, 0, 0] # force to apply
		type = 2 #kind or force mode
		
		sleep(0.02)
		zero_ftsensor()

		
		force_mode(frame, selection , wrench, type, limits)		
	
		# Up the robot
		tcp_inst = get_actual_tcp_pose()
		up_distance = p[0,0,up_tool/1000,0,0,0]
		global pos_up = pose_trans (tcp_inst, up_distance)
		pos_z = pos_up[2]
		set_payload(3.78,[-104/1000,-9/1000,-31/1000]) #back to normal tool weight
		sleep(0.1)

		movej(pos_up,accel_radss,speed_rads)
		
		while True:			
			tcp_inst = get_actual_tcp_pose()			
			if tcp_inst[2] > pos_z:
				break
			else:
				movej(pos_up,accel_radss,speed_rads)
				stopl(0.2)
			end
			sync()
		end

		end_force_mode()
		reset_register(3,4,5,5121)
	
	end	


  ##############################################################################################################################
  ##############################################################################################################################
  ##################################################### MAIN PROGRAMME #########################################################
  ##############################################################################################################################
  ##############################################################################################################################

  set_tcp(global_tcp)
  #set_payload(,[,,])
  #set_Speed(0.3, 0.75, 3, 1.2)
  #vel_ms, vel_rads, acel_ms, acel_rads
  
  #State-Machine
  while(True):
    init_status(0,1,2)
   
   if (CheckStatus(50)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5Home()
	
   elif (CheckStatus(51)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5Camera1()
	
   elif (CheckStatus(52)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5DropHead()
	
   elif (CheckStatus(53)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5Camera2()
	
   elif (CheckStatus(54)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5UpCamera1()
	
   elif (CheckStatus(55)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5TakeBuffer()
	
   elif (CheckStatus(56)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5UpCamera2()
	
   elif (CheckStatus(57)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UR5Return()
	
   elif (CheckStatus(69)==True):
    set_Speed(0.05, 0.30, 0.5, 0.6)
    UR5CkPosSepator()  

####################
   elif (CheckStatus(58)==True or CheckStatus(64)==True):
    set_Speed(0.05, 0.75, 0.25, 1.2)
    CtrCamPos(-1,-1) #58==Camera1 position & 64==UpCamera2 position

	
   elif (CheckStatus(60)==True or CheckStatus(62)==True ):
    set_Speed(0.05, 0.75, 0.25, 1.2)
    CtrCamPos(1,1) #60==Camera2 position & 62==UpCamera1 position
	
####################
   elif (CheckStatus(59)==True ):
		set_Speed(0.1, 0.75, 3, 1.2)
		MoveToNut(-1,-1,1) #59==Camera1 position 
	
	elif (CheckStatus(65)==True):
		set_Speed(0.1, 0.75, 3, 1.2)
		MoveToNut(-1,-1,4) # 65==UpCamera2 position
		
   elif (CheckStatus(61)==True ):
    set_Speed(0.1, 0.75, 3, 1.2)
    MoveToNut(1,1,2) #61==Camera2 position 
	
   elif ( CheckStatus(63)==True ):
    set_Speed(0.1, 0.75, 3, 1.2)
    MoveToNut(1,1,3) #63==UpCamera1 position	
	
####################
   
   elif (CheckStatus(66)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    UnScrew()
	
   elif (CheckStatus(67)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    Screw()
	
   elif (CheckStatus(72)==True):
    set_Speed(0.1, 0.75, 3, 1.2)
    ScrewHigh()	

	
   elif (CheckStatus(68)==True):
    set_Speed(0.1, 0.75, 2, 1.2)
    UpRobotAs(1)  
	
   elif (CheckStatus(75)==True):
    set_Speed(0.1, 0.75, 2, 1.2)
    UpRobotAs(2) 
	
   elif	(CheckStatus(70)==True):
	   set_Speed(0.1, 0.75, 3, 1.2)
	   CtrHeadTurn(1)

   
   elif	(CheckStatus(71)==True):
	   set_Speed(0.1, 0.75, 3, 1.2)
	   CtrHeadTurn(2)
	   
   elif	(CheckStatus(73)==True):
	   set_Speed(0.01, 0.75, 0.5, 1.2)	   
	   Correct_Insertion()
	   
  elif	(CheckStatus(74)==True):
	   set_Speed(0.01, 0.75, 0.5, 1.2)	   
	   Correct_Insertion_buffer()
	   
  elif	(CheckStatus(76)==True):
	   set_Speed(0.01, 0.75, 0.5, 1.2)	   
	   Correct_Insertion_hole()
	   
   end
  end
end